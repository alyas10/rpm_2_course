---
order: 4
title: "Практическая работа №4.\_Оценка сложности эвристических алгоритмов"
---

**Цель работы:** получение навыков построения алгоритмов с использованием эвристических алгоритмов

***Данную работу можно выполнить на любом языке программирования!***

## Теоретический материал

### Эвристические методы

Под эвристическими понимаются такие методы, правильность которых строго не доказывается. Они выглядят правдоподобными; кажется, что в большинстве случаев они должны давать верные решения.

**Эвристический алгоритм** -- практический метод решения задачи, не всегда гарантированно приводящий к точным или оптимальным результатам, но позволяющий ускорить выполнение поставленного задания.

Эвристический алгоритм, в отличие от точного, обладает следующими характерными особенностями:

•При использовании алгоритма результат не всегда будет гарантированно точным;

•В некоторых случаях алгоритм может привести к неверному результату;

•Возможен «пропуск цели», то есть решение не будет найдено, даже если известно, что оно заведомо существует;

•В ряде случаев может быть даже доказано, что эвристический алгоритм формально неверен. Но, несмотря на это, приемлем, если он дает неверный результат только в отдельных случаях, или же дает не абсолютно точный, но все же приемлемый результат.

Например, эвристический анализ в антивирусных программах включает использование неконкретизированных методов обнаружения для поиска новых и неизвестных вредоносных программ: код файла (или другого объекта) проверяется на наличие подозрительных инструкций. Если их количество выше установленного порога, объект блокируется.

Эвристические алгоритмы широко применяются для решения задач высокой вычислительной сложности, то есть вместо полного перебора вариантов, занимающего существенное время, а иногда технически невозможного, применяется значительно более быстрый, но недостаточно обоснованный теоретически, алгоритм.

### Муравьиные алгоритмы

Предположим у меня есть сахар и я положу его недалеко от муравейника. Каким маршрутом пойдут муравьи?

![](./_index.pn_index){width=2028px height=907px}

Среди экспериментов по выбору между двумя путями неравной длины, ведущих от колонии к источнику питания, биологи заметили, что, как правило, муравьи используют кратчайший маршрут.

![](./_index-2.pn_index){width=2027px height=908px}

Модель такого поведения заключается в следующем:

Муравей проходит от колонии по пути, выбранному случайным образом.

1. Если он находит источник пищи, то возвращается в гнездо, оставляя за собой след из феромона. Феромо́ны (др.-греч. φέρω -- несу + ὁρμάω -- возбуждаю, побуждаю) -- собирательное название веществ -- продуктов внешней секреции, выделяемых некоторыми видами животных и обеспечивающих химическую коммуникацию между особями одного вида.

2. Эти феромоны привлекают других муравьёв, находящихся вблизи, которые вероятнее всего пойдут по этому маршруту.

3. Вернувшись в гнездо, они «укрепят» феромонную тропу.

4. Если существует 2 маршрута, то по более короткому за то же время успеют пройти больше муравьёв, чем по длинному. Короткий маршрут станет более привлекательным.

5. Длинные пути, в конечном итоге, исчезнут из-за испарения феромонов.

Описанная система перемещения муравьев базируется на положительной (другие муравьи укрепляют феромонную тропу) и отрицательной (испарение феромонной тропы) обратной связей. Первая версия «муравьиного» алгоритма, предложенная доктором наук Марко Дориго в 1992 году, была направлена на поиск оптимального пути в графе.

Сотня муравьев – сотня попыток

![](./_index._indexif){width=800px height=450px}

![](./_index-3.pn_index){width=734px height=804px}



[tabs]

[tab:Решение на C++]

[aco.cpp](./aco.cpp)

[/tab]

[tab:Решение на Python]

<https://inzhenerka.tech/blog/tpost/k722n4lty1-kak-reshit-zadachu-kommivoyazhyora-metod>

<https://ratcatcher.ru/alg/Лекции/Лекция%20B/lec_11/>

[/tab]

[tab]



[/tab]

[/tabs]

### Оценка сложности эвристических алгоритмов

Как правило, временная сложность алгоритма зависит от исходных данных. Это может быть зависимость как от величины исходных данных, так и от их объема. Если обозначить значение параметра временной сложности алгоритма α символом Tα, а буквой V обозначить некоторый числовой параметр, характеризующий исходные данные, то временную сложность можно представить как функцию Tα(V). Выбор параметра V зависит от решаемой задачи или от вида используемого алгоритма для решения данной задачи.

Ход работы 1. Оценим временную сложность алгоритма вычисления факториала целого положительного числа.

```
static long CalculateFactorialIterative(int x) { 
long factorial = 1; 
for (int i = 1; i <= x; i++) 
{ 
factorial *= i; 
} 
return factorial; 
}
```

Подсчитаем общее число операций, выполняемых программой при данном значении x. Один раз выполняется оператор factorial = 1; тело цикла (в котором две операции: умножение и присваивание) выполняется х -- 1 раз;

Если каждую из операций принять за единицу сложности, то временная сложность всего алгоритма будет 1 + 2 (x -- 1) = 2х Отсюда понятно, что в качестве параметра следует принять значение х. Функция временной сложности получилась следующей: Tα(V)=2V. В этом случае можно сказать, что временная сложность зависит линейно от параметра данных -- величины аргумента функции факториал.

### Что такое жадные алгоритмы?

\
[Жадный алгоритм](http://ru.wikipedia.org/wiki/%D0%96%D0%B0%D0%B4%D0%BD%D1%8B%D0%B9_%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC) (greedy algorithm) -- это алгоритм, который на каждом шагу делает локально наилучший выбор в надежде, что итоговое решение будет оптимальным. Суть жадного алгоритма заключается в том, что он **каждый раз выбирает наилучший вариант из возможных**. Например, монету с самым большим номиналом, самое короткое выступление и т.д.

:::quote 

Постановка задачи

Какое наибольшее число можно составить из цифр 9, 8, 9, 6, 1? Используйте все цифры.

:::

![](./_index-4.pn_index){width=1749px height=208px}

\{9, 8, 9, 6, 1}   ->  ? ? ? ? ?

1\.Найти максимальную цифру

2\. Добавить ее к номеру: \{9, 8, 9, 6, 1}  ->  9

3\. Удалить ее из списка: \{8, 9, 6, 1}  ->  9

4\. Повторите, пока есть цифры в списке

\{8, 6, 1}  ->  99

\{6, 1}  ->  998

\{1}  ->  9986

\{}  ->  99861

Жадная стратегия:

-  Сделать жадный выбор

-  Свести к меньшей подзадаче

-  Повторить

**Задача о сдаче денег**. Есть монеты достоинством 50, 10, 5 копеек и 1 копейка, нужно вернуть сдачу в 63 копейки наименьшим количеством монет.

**Решение**:

1. Выбрать монету самого большого достоинства (50 копеек), но не больше 63 копеек, добавить её в список сдачи и вычесть её стоимость из 63 (получится 13 копеек).

2. Снова выбрать монету самого большого достоинства, но не больше остатка (13 копеек): это монета в 10 копеек.

3. Добавить её в список сдачи, вычесть её стоимость из остатка и т. д..

В итоге получится одна монета по 50 копеек, одна монета в 10 копеек и три монеты по одной копейке.

### Когда жадный алгоритм не сработает

Пусть у нас есть следующий набор монет: `[1, 4, 5]`. Теперь допустим, нам нужно разменять сумму `8`.

Если мы применим жадный алгоритм к этому набору монет, он сначала выберет монету с номиналом `5`, так как она имеет наибольший номинал. Затем, чтобы разменять оставшуюся сумму `3`, алгоритм выберет три монеты по `1`. В итоге, жадный алгоритм использует 4 монеты: `[5, 1, 1, 1]`.

Однако, оптимальное решение здесь -- использовать две монеты по `4` (сумма `8` разменяется на `[4, 4]`). В этом случае, жадный алгоритм не приводит к оптимальному результату.

**Пример кода:**

<https://www.geeksforgeeks.org/dsa/introduction-to-greedy-algorithm-data-structures-and-algorithm-tutorials/>

Метод жадных алгоритмов являтся весьма распространненым и известным.

Известные жадные алгоритмы:

-  **Алгоритм Хаффмана** - алгоритм оптимального префиксного кодирования алфавита с минимальной избыточностью

-  **Алгоритм Крускала** - алгоритм поиска минимального остовного дерева во взвешенном неориентированном связном графе

-  **Алгоритм  Прима** - алгоритм поиска минимального остовного дерева взвешенного связного неориентированного графа

-  **Алгоритм Дейкстры** - алгоритм поиска кратчайших путей от одной из вершин графа до всех остальных вершин графа

и т.д.

## Требования к отчету

**Структура отчета:**

1. **Титульный лист**

2. **Цель работы**

3. **Условие задания**

4. **Код программы**

5. **Скриншоты тестирования программы**

6. **Заполненные таблицы**

7. **Построенный график зависимости к задаче 1**

8. **Вывод по цели работы**

## Примечания

**Оценка 5:**

-  Работа оформлена по образцу

-  Полностью решены все 4 задания

-  В Задании 1 заполнена таблица и программно построен график

-  В Заданиях 2 и 3 заполнены все таблицы с результатами

-  В Задании 4 выполнен аналитический анализ и подготовлен конспект эвристического алгоритма

**Оценка 4:**

-  Работа оформлена по образцу

-  Решены 3 задания (1, 2, 3)

-  В Задании 1 заполнена таблица и построен график (программно или в Excel)

-  В Заданиях 2 и 3 заполнены таблицы с результатами

**Оценка 3:**

-  Работа оформлена по образцу

-  Решены 2 задания (1, 2)

-  В Задании 1 заполнена таблица и построен график (программно или в Excel)

-  В Задании 2 заполнена таблица с результатами